////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
//= Building a Native Executable
= 构建本机可执行文件
include::./attributes.adoc[]

//This guide covers:
本教程涵盖：

//* Compiling the application to a native executable
* 将应用程序编译为本机可执行文件
//* Packaging the native executable in a container
* 将本机可执行文件打包到容器中
//* Debugging native executable
* 调试本机可执行文件

//This guide takes as input the application developed in the xref:getting-started.adoc[Getting Started Guide].
本教程将以 xref:getting-started-CN.adoc[创建第一个应用] 中开发的程序作为基本程序。

== GraalVM

//Building a native executable requires using a distribution of GraalVM.
//There are three distributions:
//Oracle GraalVM Community Edition (CE), Oracle GraalVM Enterprise Edition (EE) and Mandrel.
//The differences between the Oracle and Mandrel distributions are as follows:
构建本机可执行文件需要使用 GraalVM 的发行版本。GraalVM 有三个发行版本： Oracle GraalVM Community Edition (CE)、 Oracle GraalVM Enterprise Edition (EE)和 Mandrel。Oracle 和 Mandrel 发行版之间的区别如下。


//* Mandrel is a downstream distribution of the Oracle GraalVM CE.
//Mandrel's main goal is to provide a way to build native executables specifically designed to support Quarkus.

* Mandrel 是 Oracle GraalVM CE 的下游发行版。Mandrel 的主要目标是提供一种构建本机可执行文件的方法，该可执行文件专门设计用于支持 Quarkus。

//* Mandrel releases are built from a code base derived from the upstream Oracle GraalVM CE code base,
//with only minor changes but some significant exclusions that are not necessary for Quarkus native apps.
//They support the same capabilities to build native executables as Oracle GraalVM CE,
//with no significant changes to functionality.
//Notably, they do not include support for polyglot programming.
//The reason for these exclusions is to provide a better level of support for the majority of Quarkus users.
//These exclusions also mean Mandrel offers a considerable reduction in its distribution size
//when compared with Oracle GraalVM CE/EE.

Mandrel 版本是根据从上游 Oracle GraalVM CE 代码库派生的代码库构建的，只有微小的更改，
但有一些对 Quarkus 本机应用程序不需要的重要排除项。它们支持与 Oracle GraalVM CE 相同的构建本机可执行文件的功能，而功能没有重大变化。
值得注意的是，它们不包括对多语言编程的支持。这些排除的原因是为大多数 Quarkus 用户提供更好的支持。与 Oracle GraalVM CE/EE 相比，这些排除项还意味着 Mandrel 的规模显着减小。

//* Mandrel is built slightly differently to Oracle GraalVM CE, using the standard OpenJDK project.
//This means that it does not profit from a few small enhancements that Oracle have added to the version of OpenJDK used to build their own GraalVM downloads.
//This enhancements are omitted because upstream OpenJDK does not manage them, and cannot vouch for.
//This is particularly important when it comes to conformance and security.

* Mandrel 中使用标准 OpenJDK 与 Oracle GraalVM CE 略有不同。 这意味着它不会从 Oracle 添加 GraalVM 所需的 OpenJDK。这些增强被省略了，因为上游 OpenJDK 不管理它们，也不能保证。这在一致性和安全性方面尤为重要。

//* Mandrel is recommended for building native executables that target Linux containerized environments.
//This means that Mandrel users are encouraged to use containers to build their native executables.
//If you are building native executables for macOS,
//you should consider using Oracle GraalVM instead,
//because Mandrel does not currently target this platform.
//Building native executables directly on bare metal Linux or Windows is possible,
//with details available in the https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README]
//and https://github.com/graalvm/mandrel/releases[Mandrel releases].
建议使用 Mandrel 构建面向 Linux 容器化环境的本机可执行文件。这意味着鼓励 Mandrel 用户使用容器来构建他们的本地可执行文件。如果您正在为 macOS 构建本机可执行文件，则应考虑改用 Oracle GraalVM，因为 Mandrel 目前不针对此平台。可以直接在 Linux 或 Windows 上构建本机可执行文件，详细信息请查阅 https://github.com/graalvm/mandrel/blob/default/README.md[Mandrel README]和 https://github.com/graalvm/mandrel/releases[Mandrel 发布信息]。

//== Prerequisites
== 前提

:prerequisites-docker:
:prerequisites-graalvm-mandatory:
include::includes/devtools/prerequisites-CN.adoc[]
* 一个 xref:configuring-c-development[C 语言开发环境]
//* The code of the application developed in the xref:getting-started-CN.adoc[Getting Started Guide].
* 部署程序来自 xref:getting-started-CN.adoc[创建第一个应用].

//.Supporting native compilation in C
.支持C语言原生编译
[[configuring-c-development]]
[NOTE]
====
//What does having a working C developer environment mean?
如何拥有 C 语言开发环境

//* On Linux, you will need GCC, and the glibc and zlib headers. Examples for common distributions:
* 在 Linux 中您需要安装 GCC 、glibc 和 zlib ，执行命令如下
+
[source,bash]
----
# dnf (rpm-based)
sudo dnf install gcc glibc-devel zlib-devel libstdc++-static
# Debian-based distributions:
sudo apt-get install build-essential libz-dev zlib1g-dev
----
//* XCode provides the required dependencies on macOS:
* 在 macOS 中您需要通过下面代码进行安装：
+
[source,bash]
----
xcode-select --install
----
//* On Windows, you will need to install the https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]
* 在 Windows 中您需要安装 https://aka.ms/vs/15/release/vs_buildtools.exe[Visual Studio 2017 Visual C++ Build Tools]
====

[[configuring-graalvm]]
//=== Configuring GraalVM
=== 配置 GraalVM

[TIP]
====
//If you cannot install GraalVM, you can use a multi-stage Docker build to run Maven inside a Docker container that embeds GraalVM. There is an explanation of how to do this at the end of this guide.
如果您无法安装 GraalVM ，可以使用多阶段 Docker 构建，在 Docker 容器中使用Maven构建，此时会使用嵌入式的 GraalVM 。本教程的末尾会介绍如何执行此操作。
====

//Version {graalvm-version} is required. Using the community edition is enough.
需要使用GraalVM的版本是 {graalvm-version} ，本教程中使用社区版本足以。

//1. Install GraalVM if you haven't already. You have a few options for this:
1. 如果您还没有安装 GraalVM ，您有一下几种选择进行安装：
//** Download the appropriate archive from <https://github.com/graalvm/mandrel/releases> or <https://github.com/graalvm/graalvm-ce-builds/releases>, and unpack it like you would any other JDK.
** 从 <https://github.com/graalvm/mandrel/releases> 或 <https://github.com/graalvm/graalvm-ce-builds/releases> 下载发布版本，然后向解压其他JDK一样解压。
//** Use platform-specific install tools like https://sdkman.io/jdks#Oracle[sdkman], https://github.com/graalvm/homebrew-tap[homebrew], or https://github.com/ScoopInstaller/Java[scoop].
** 使用特定平台的安装工具，例如 https://sdkman.io/jdks#Oracle[sdkman], https://github.com/graalvm/homebrew-tap[homebrew] 或者 https://github.com/ScoopInstaller/Java[scoop]。
//2. Configure the runtime environment. Set `GRAALVM_HOME` environment variable to the GraalVM installation directory, for example:
2. 配置运行时环境，需要设置 `GRAALVM_HOME` 变量为 GraalVM 的安装目录，例如：
+
[source,bash]
----
export GRAALVM_HOME=$HOME/Development/graalvm/
----
+
//On macOS (not supported by Mandrel), point the variable to the `Home` sub-directory:
在 macOS （不支持 Mandrel 版本），将环境变量指向子目录 `Home` ,例如：
+
[source,bash]
----
export GRAALVM_HOME=$HOME/Development/graalvm/Contents/Home/
----
+
//On Windows, you will have to go through the Control Panel to set your environment variables.
在 Windows中您需要通过控制面板来配置环境变量。
+
[TIP]
====
//Installing via scoop will do this for you.
如果通过 scoop 安装将为您完成环境变量配置操作。
====
//3. (Only for Oracle GraalVM CE/EE) Install the `native-image` tool using `gu install`:
3. 仅适用于 Oracle GraalVM CE/EE，使用以下命令安装 `native-image` ：
+
[source,bash]
----
${GRAALVM_HOME}/bin/gu install native-image
----
+
//Some previous releases of GraalVM included the `native-image` tool by default.  This is no longer the case; it must be installed as a second step after GraalVM itself is installed. Note: there is an outstanding issue xref:graal-and-catalina[using GraalVM with macOS Catalina].
在早一些的 GraalVM 版本会默认携带 `native-image` 工具。现在的发行版本中不会携带 `native-image` 工具，建议在 GraalVM 安装完成后为第二步操作。注意: 在 macOs中使用会遇到问题，具体内容查看 xref:graal-and-catalina[在 macOS Catalina 中使用 GraalVM].
//4. (Optional) Set the `JAVA_HOME` environment variable to the GraalVM installation directory.
4. （可选）将 `JAVA_HOME` 环境变量设置为 GraalVM 安装目录。
+
[source,bash]
----
export JAVA_HOME=${GRAALVM_HOME}
----
//5. (Optional) Add the GraalVM `bin` directory to the path
5.（可选）将 GraalVM `bin` 目录添加到 `$PATH` 中
+
[source,bash]
----
export PATH=${GRAALVM_HOME}/bin:$PATH
----

[[graal-and-catalina]]
//.Issues using GraalVM with macOS Catalina
.在 macOS Catalina 中使用 GraalVM 的问题
[NOTE]
====
//GraalVM binaries are not (yet) notarized for macOS Catalina as reported in this https://github.com/oracle/graal/issues/1724[GraalVM issue]. This means that you may see the following error when using `gu`:

如 https://github.com/oracle/graal/issues/1724[GraalVM 使用问题] 描述，GraalVM 二进制文件没有对 macOS Catalina 进行公证，这意味在使用 `gu` 时可能会看到如下错误

[source,bash]
----
“gu” cannot be opened because the developer cannot be verified
----

//Use the following command to recursively delete the `com.apple.quarantine` extended attribute on the GraalVM install directory as a workaround:
如果需要解决上述问题可以使用命令递归删除 `com.apple.quarantine` 下的内容，命令如下

[source,bash]
-----
xattr -r -d com.apple.quarantine ${GRAALVM_HOME}/../..
-----
====

//== Solution
== 源码获取

//We recommend that you follow the instructions in the next sections and package the application step by step. However, you can go right to the completed example.
我们建议您按照本教程的说明一步一步完成应用程序的打包。但是，您可以直接跳转到完整实例：

//Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].
克隆 Git 仓库 `git clone {quickstarts-clone-url}`, 或者 下载 {quickstarts-archive-url}[archive].

//The solution is located in the `getting-started` directory.
源代码程序位于 `getting-started` 目录

//== Producing a native executable
== 生成本机可执行文件

//The native executable for our application will contain the application code, required libraries, Java APIs, and a reduced version of a VM. The smaller VM base improves the startup time of the application and produces a minimal disk footprint.
我们生成的本机可执行文件将会包含应用程序代码、依赖库、Java API 和 VM的简化版本。较小的 VM 可以改变应用程序启动时所需的时间以及磁盘占用控件。

image:native-executable-process.png[Creating a native executable]

//If you have generated the application from the previous tutorial, you can find in the `pom.xml` the following _profile_:
如果您从上一个教程中生成应用程序，您会在 `pom.xml` 中看到如下配置：

[source,xml]
----
<profiles>
    <profile>
        <id>native</id>
        <properties>
            <quarkus.package.type>native</quarkus.package.type>
        </properties>
    </profile>
</profiles>
----

[TIP]
====
//You can provide custom options for the `native-image` command using the `<quarkus.native.additional-build-args>` property.
//Multiple options may be separated by a comma.
您可以使用 `<quarkus.native.additional-build-args>` 属性为 `native-image` 命令提供自定义配置，多个参数使用逗号( `,` ) 分割。

//Another possibility is to include the `quarkus.native.additional-build-args` configuration property in your `application.properties`.
另一种可能是通过 `application.properties` 文件中的 `quarkus.native.additional-build-args` 属性进行配置。
//You can find more information about how to configure the native image building process in the <<configuration-reference>> section below.
您可以通过阅读 <<configuration-reference>> 查看更多本地可执行文件构建时所需参数信息。
====

//We use a profile because, you will see very soon, packaging the native executable takes a _few_ minutes. You could
//just pass -Dquarkus.package.type=native as a property on the command line, however it is better to use a profile as
//this allows native image tests to also be run.
我们使用配置文件的原因是，打包本地可执行文件需要话费几分钟的时间。您可以在构建命令上增加 `-Dquarkus.package.type=native` 作为构建属性进行传递，但最好使用配置文件，因为这样允许本地可执行文件的测试。


//Create a native executable using:
您可以使用以下命令创建本机可执行文件：

include::includes/devtools/build-native.adoc[]

[[graal-and-windows]]
[NOTE]
//.Issues with packaging on Windows
.Windows 上的打包问题
====
//The Microsoft Native Tools for Visual Studio must first be initialized before packaging. You can do this by starting
//the `x64 Native Tools Command Prompt` that was installed with the Visual Studio Build Tools. At
//`x64 Native Tools Command Prompt` you can navigate to your project folder and run `mvnw package -Pnative`.

在 Microsoft Native Tools 中需要先进行 Visual Studio 的初始化。您可以通过启动 `x64 Native Tools Command Prompt` 与 Visual Studio Build Tools 。`x64 Native Tools Command Prompt` 工具可以导航到到您的工作目录并执行 `mvnw package -Pnative`.



//Another solution is to write a script to do this for you:
另一种解决方案是编写一个脚本来为您执行此操作：

[source,bash]
----
cmd /c 'call "C:\Program Files (x86)\Microsoft Visual Studio\2017\BuildTools\VC\Auxiliary\Build\vcvars64.bat" && mvn package -Pnative'
----
====

//In addition to the regular files, the build also produces `target/getting-started-1.0.0-SNAPSHOT-runner`.
//You can run it using: `./target/getting-started-1.0.0-SNAPSHOT-runner`.

除了常规文件以外，构建后还会生成 `target/getting-started-1.0.0-SNAPSHOT-runner` 文件，您可以通过以下命令执行它： `./target/getting-started-1.0.0-SNAPSHOT-runner`。

[[graal-package-preview]]
[NOTE]
//.Java preview features
.Java 预览功能
====
//Java code that relies on preview features requires special attention.
//To produce a native executable, this means that the `--enable-preview` flag needs to be passed to the underlying native image invocation.
//You can do so by prepending the flag with `-J` and passing it as additional native build argument: `-Dquarkus.native.additional-build-args=-J--enable-preview`.
如果您需要依赖Java预览功能，在生成本地可执行文件时需要添加 `--enable-preview` 配置。您也可以通过在命令前添加 `-J` 将其作为构建参数，具体示例：`-Dquarkus.native.additional-build-args=-J--enable-preview`。
====

//== Testing the native executable
== 测试本地可执行文件

//Producing a native executable can lead to a few issues, and so it's also a good idea to run some tests against the application running in the native file.
生成的本地可执行文件可能会存在一些问题，因此对本地可执行文件中的应用程序进行测试是一个好主意。

//In the `pom.xml` file, the `native` profile contains:
在 `pom.xml` 文件中 ，`native` 配置信息如下：

[source, xml]
----
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-failsafe-plugin</artifactId>
    <version>${surefire-plugin.version}</version>
    <executions>
        <execution>
            <goals>
                <goal>integration-test</goal>
                <goal>verify</goal>
            </goals>
            <configuration>
                <systemPropertyVariables>
                    <native.image.path>${project.build.directory}/${project.build.finalName}-runner</native.image.path>
                    <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>
                    <maven.home>${maven.home}</maven.home>
                </systemPropertyVariables>
            </configuration>
        </execution>
    </executions>
</plugin>
----

//This instructs the failsafe-maven-plugin to run integration-test and indicates the location of the produced native executable.
插件 failsafe-maven-plugin 会在运行时集成测试并将测试结果生成。

//Then, open the `src/test/java/org/acme/quickstart/GreetingResourceIT.java`. It contains:
打开 `src/test/java/org/acme/quickstart/GreetingResourceIT.java` 文件，内容如下：

[source,java]
----
package org.acme.quickstart;


import io.quarkus.test.junit.QuarkusIntegrationTest;

@QuarkusIntegrationTest // <1>
public class GreetingResourceIT extends GreetingResourceTest { // <2>

    // Run the same tests

}
----
//<1> Use another test runner that starts the application from the native file before the tests.
//The executable is retrieved using the `native.image.path` system property configured in the _Failsafe Maven Plugin_.
<1> 使用另一个测试运行程序，在测试之前从本机文件启动应用程序。使用 Failsafe Maven Plugin `native.image.path` 中配置的系统属性检索可执行文件。
//<2> We extend our previous tests, but you can also implement your tests
<2> 我们扩展了我们之前的测试，您也可以实现你的测试
//To see the `GreetingResourceIT` run against the native executable, use `./mvnw verify -Pnative`:
要查看 `GreetingResourceIT` 针对本机可执行文件的运行输出，请使用 `./mvnw verify -Pnative` :


[source,shell]
----
$ ./mvnw verify -Pnative
...
[getting-started-1.0.0-SNAPSHOT-runner:18820]     universe:     587.26 ms
[getting-started-1.0.0-SNAPSHOT-runner:18820]      (parse):   2,247.59 ms
[getting-started-1.0.0-SNAPSHOT-runner:18820]     (inline):   1,985.70 ms
[getting-started-1.0.0-SNAPSHOT-runner:18820]    (compile):  14,922.77 ms
[getting-started-1.0.0-SNAPSHOT-runner:18820]      compile:  20,361.28 ms
[getting-started-1.0.0-SNAPSHOT-runner:18820]        image:   2,228.30 ms
[getting-started-1.0.0-SNAPSHOT-runner:18820]        write:     364.35 ms
[getting-started-1.0.0-SNAPSHOT-runner:18820]      [total]:  52,777.76 ms
[INFO]
[INFO] --- maven-failsafe-plugin:2.22.1:integration-test (default) @ getting-started ---
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running org.acme.quickstart.GreetingResourceIT
Executing [/data/home/gsmet/git/quarkus-quickstarts/getting-started/target/getting-started-1.0.0-SNAPSHOT-runner, -Dquarkus.http.port=8081, -Dtest.url=http://localhost:8081, -Dquarkus.log.file.path=build/quarkus.log]
2019-04-15 11:33:20,348 INFO  [io.quarkus] (main) Quarkus 999-SNAPSHOT started in 0.002s. Listening on: http://[::]:8081
2019-04-15 11:33:20,348 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.387 s - in org.acme.quickstart.GreetingResourceIT
...
----

[TIP]
====
//By default, Quarkus waits for 60 seconds for the native image to start before automatically failing the native tests. This
//duration can be changed using the `quarkus.test.wait-time` system property. For example, to increase the duration
//to 300 seconds, use: `./mvnw verify -Pnative -Dquarkus.test.wait-time=300`.

默认情况下，Quarkus 会等待60秒以启动本地可执行文件，然后自动使本地测试失败。可以通过 `quarkus.test.wait-time` 变量改变等待时间，例如需要将等待时间变为300秒，请使用 `./mvnw verify -Pnative -Dquarkus.test.wait-time=300` 命令。
====

[WARNING]
====
//This procedure was formerly accomplished using the `@NativeImageTest` annotation. `@NativeImageTest` is considered deprecated in favor of `@QuarkusIntegrationTest` which provides a superset of the testing
//capabilities of `@NativeImageTest`. More information about `@QuarkusIntegrationTest` can be found in the xref:getting-started-testing.adoc#quarkus-integration-test[Testing Guide].

之前的测试是使用 `@NativeImageTest` 注解完成的，`@NativeImageTest` 注解在现在已经被认为是一个启用的注解，新的注解是 `@QuarkusIntegrationTest` ，它代替了 `@NativeImageTest` 注解。更多关于 `@QuarkusIntegrationTest` 注解的信息查看 xref:getting-started-testing-CN.adoc#quarkus-integration-test[测试教程].
====

//By default, integration tests runs using the `prod` profile.
//This can be overridden using the `quarkus.test.native-image-profile` property.
//For example, in your `application.properties` file, add: `quarkus.test.native-image-profile=test`.
//Alternatively, you can run your tests with: `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test`.
//However, don't forget that when the native executable is built the `prod` profile is enabled.
//So, the profile you enable this way must be compatible with the produced executable.

在默认情况下，集成测试使用 `prod` 配置运行。想要改变配置可以使用 `quarkus.test.native-image-profile` 属性进行覆盖。例如在您的 `application.properties` 文件中，添加 `quarkus.test.native-image-profile=test`。或者，您可以使用以下目录运行测试： `./mvnw verify -Pnative -Dquarkus.test.native-image-profile=test` 。但是，不要忘记在构建本机可执行文件是启用 `prod` 配置。因此您以这种方式启用的可执行文件必须与生成的可执行文件兼容。


[[graal-test-preview]]
[NOTE]
//.Java preview features
.Java 预览功能
====
//Java code that relies on preview features requires special attention.
//To test a native executable, this means that the `--enable-preview` flag needs to be passed to the Surefire plugin.
//Adding `<argLine>--enable-preview</argLine>` to its `configuration` section is one way to do so.

依赖Java预览功能的代码需要特别注意。测试本机可执行文件必须传递 `--enable-preview` 属性给Surefire插件。也可以通过在 `configuration` 中添加 `<argLine>--enable-preview</argLine>` 属性
====

//=== Excluding tests when running as a native executable
=== 本机可执行文件运行时测试

//When running tests this way, the only things that actually run natively are you application endpoints, which
//you can only test via HTTP calls. Your test code does not actually run natively, so if you are testing code
//that does not call your HTTP endpoints, it's probably not a good idea to run them as part of native tests.

以这类方式运行测试，唯一的价值是在本地运行应用程序端点，您只能通过 HTTP 对其进行调用测试。您的测试代码实际上并没有在本地执行，因此您如果正在测试不调用 HTTP 端点的代码，那么将它们作为本机测试的一部分运行可能不是一个好主意。


//If you share your test class between JVM and native executions like we advise above, you can mark certain tests
//with the `@DisabledOnNativeImage` annotation in order to only run them on the JVM.

如果您像我们上面建议的哪样在JVM和本机执行测试类之间共享您的测试类，您可以使用 `@DisabledOnNativeImage` 注解标某些测试类或者方法，以便于仅在JVM上运行测试。


//=== Testing an existing native executable
=== 测试现有的本机可执行文件

//It is also possible to re-run the tests against a native executable that has already been built. To do this run
//`./mvnw test-compile failsafe:integration-test`. This will discover the existing native image and run the tests against it using
//failsafe.

您还可以针对已经构建完成的本机可执行文件进行测试，通过`./mvnw test-compile failsafe:integration-test` 命令进行，浙江发现现有本地可执行文件的故障。

//If the process cannot find the native image for some reason, or you want to test a native image that is no longer in the
//target directory you can specify the executable with the `-Dnative.image.path=` system property.
如果由于模型原因找不到本地可执行文件，或者您想要自定义本地可执行文件，可以使用 `-Dnative.image.path=` 属性指定本地可执行文件。

[#container-runtime]
//== Creating a Linux executable without GraalVM installed
== 在未安装GraalVM的Linux中创建可执行文件

//IMPORTANT: Before going further, be sure to have a working container runtime (Docker, podman) environment. If you use Docker
//on Windows you should share your project's drive at Docker Desktop file share settings and restart Docker Desktop.

IMPORTANT: 在继续之前，请确保有一个可以使用的容器（Docker、podman）环境。如果您在Windows上使用Docker，您应该在 Docker Desktop 文件共享设置中共享您的项目驱动器并重启Docker Desktop。


//Quite often one only needs to create a native Linux executable for their Quarkus application (for example in order to run in a containerized environment) and would like to avoid
//the trouble of installing the proper GraalVM version in order to accomplish this task (for example, in CI environments it's common practice
//to install as little software as possible).

大多数时候，我们只需要生成在Linux上的本地可执行程序（例如，为了在容器环境中运行），并且希望避免安装 GraalVM 来完成这项任务（例如，在CI环境中，希望尽可能的安装少的软件）。

//To this end, Quarkus provides a very convenient way of creating a native Linux executable by leveraging a container runtime such as Docker or podman.
//The easiest way of accomplishing this task is to execute:
为此，Quarkus 提供了一种非常方便的方法，通过容器运行时来创建Linux下本机可执行文件。完成此任务的最简单命令如下


include::includes/devtools/build-native-container.adoc[]

[TIP]
====
//By default Quarkus automatically detects the container runtime.
//If you want to explicitely select the container runtime, you can do it with:
默认情况下，Quarkus会在启动时检测容器环境，如果您想明确容器，可以进行如下操作：


针对 Docker:

:build-additional-parameters: -Dquarkus.native.container-runtime=docker
include::includes/devtools/build-native-container-parameters.adoc[]
:!build-additional-parameters:

针对 podman:

:build-additional-parameters: -Dquarkus.native.container-runtime=podman
include::includes/devtools/build-native-container-parameters.adoc[]
:!build-additional-parameters:

//These are normal Quarkus config properties, so if you always want to build in a container
//it is recommended you add these to your `application.properties` in order to avoid specifying them every time.

上述命令中所使用的Quarkus配置属性都是普通配置，如果您总是想通过容器模式构建本地可执行文件，建议您将这些配置放在 `application.properties` 文件中，避免每次都指定它们。

====

[TIP]
====
If you see the following invalid path error for your application JAR when trying to create a native executable using a container build,
even though your JAR was built successfully, you're most likely using a remote daemon for your container runtime.

如果您在尝试使用容器构建本地可执行文件时看到 JAR 路径无效，即使您的 JAR 已成功构建，JAR在容器中以远程守护进程运行。

----
Error: Invalid Path entry getting-started-1.0.0-SNAPSHOT-runner.jar
Caused by: java.nio.file.NoSuchFileException: /project/getting-started-1.0.0-SNAPSHOT-runner.jar
----
//In this case, use the parameter `-Dquarkus.native.remote-container-build=true` instead of `-Dquarkus.native.container-build=true`.
在这种情况下，请使用参数 `-Dquarkus.native.remote-container-build=true` 而不是 `-Dquarkus.native.container-build=true` 解决问题。


//The reason for this is that the local build driver invoked through `-Dquarkus.native.container-build=true` uses volume mounts to make the JAR available in the build container, but volume mounts do not work with remote daemons. The remote container build driver copies the necessary files instead of mounting them. Note that even though the remote driver also works with local daemons, the local driver should be preferred in the local case because mounting is usually more performant than copying.
原因是通过 `-Dquarkus.native.container-build=true` 使用外挂驱动使得JAR在构建容器中可用，但是在挂载驱动中不可用。远程容器构建驱动程序应该复制必要的文件，而不是挂载这些文件。请注意，即使远程驱动程序也可以与本地守护程序一起使用，但是在本地环境下应该首选本地驱动程序，因为挂载通常比赋值具有更高的性能。
====

[TIP]
====
//Building with Mandrel requires a custom builder image parameter to be passed additionally:

使用 Mandrel 构建需要传递一个自定义参数

:build-additional-parameters: -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}
include::includes/devtools/build-native-container-parameters.adoc[]
:!build-additional-parameters:

//Please note that the above command points to a floating tag.
//It is highly recommended to use the floating tag,
//so that your builder image remains up-to-date and secure.
//If you absolutely must, you may hard-code to a specific tag
//(see https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[here] for available tags),
//but be aware that you won't get security updates that way and it's unsupported.

请注意，上述命令指向了一个可变标签。强烈建议使用可变标签，以便您的构建结果保持最新且安全。如果您绝对必须可以使用特定标签，具体可以查看 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[文档]，如果使用这种方式需要注意，无法获取最新且安全的镜像。
====

//== Creating a container
== 创建容器

//=== Using the container-image extensions
=== 使用容器镜像拓展

//By far the easiest way to create a container-image from your Quarkus application is to leverage one of the container-image extensions.
到目前为止，从 Quarkus 应用程序创建容器镜像最简单的方式就是使用拓展程序。

//If one of those extensions is present, then creating a container image for the native executable is essentially a matter of executing a single command:
如果存在一个拓展程序，为本机可执行文件创建镜像本质上是执行一个命令，命令示例如下：

[source,bash]
----
./mvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true
----

//* `quarkus.native.container-build=true` allows for creating a Linux executable without GraalVM being installed (and is only necessary if you don't have GraalVM installed locally or your local operating system is not Linux)
* `quarkus.native.container-build=true` 允许在不安装 GraalVM 的情况下创建Linux下的可执行文件，（仅当您没有在本地安装 GraalVM 或者您的操作系统不是 Linux 时才需要）
//* `quarkus.container-image.build=true` instructs Quarkus to create a container-image using the final application artifact (which is the native executable in this case)
* `quarkus.container-image.build=true` 表示 Quarkus 使用最终应用程序组件（在本例中是本地可执行文件）镜像。

//See the xref:container-image.adoc[Container Image guide] for more details.
跟多关于容器镜像内容查看 xref:container-image-CN.adoc[容器镜像教程]

//=== Manually using the micro base image
=== 手动使用镜像

//You can run the application in a container using the JAR produced by the Quarkus Maven Plugin.
//However, in this section we focus on creating a container image using the produced native executable.

您可以使用 Quarkus Maven 插件生成的 JAR 在容器中运行应用程序。但是，在本节中我们将专注于如何使用本地可执行文件创建容器镜像。

image:containerization-process.png[Containerization Process]

//When using a local GraalVM installation, the native executable targets your local operating system (Linux, macOS, Windows etc).
//However, as a container may not use the same _executable_ format as the one produced by your operating system,
//we will instruct the Maven build to produce an executable by leveraging a container runtime (as described in <<#container-runtime,this section>>):
使用本地 GraalVM 安装时，本地可执行文件将针对您的操作系统进行变化。但是，由于容器可能不会使用与操作系统相同的可执行文件，我们将使用Maven构建指定可执行文件 具体参考<<#container-runtime,前文>>


//The produced executable will be a 64 bit Linux executable, so depending on your operating system it may no longer be runnable.
//However, it's not an issue as we are going to copy it to a container.
//The project generation has provided a `Dockerfile.native-micro` in the `src/main/docker` directory with the following content:

生成的可执行文件是 64位的Linux可执行文件，因此可能子啊您的操作系统中会存在不可用的情况。但是，这不是一个问题，因为我们会将其复制到容器中，项目生成后会在 `src/main/docker` 目录下提供 `Dockerfile.native-micro` 文件，内容如下。


[source,dockerfile]
----
FROM quay.io/quarkus/quarkus-micro-image:1.0
WORKDIR /work/
COPY target/*-runner /work/application
RUN chmod 775 /work
EXPOSE 8080
CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
----

[NOTE]
.Quarkus Micro Image?
.Quarkus最小镜像
====
//The Quarkus Micro Image is a small container image providing the right set of dependencies to run your native application.
//It is based on https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro].
//This base image has been tailored to work perfectly in containers.

Quarkus Micro Image 是一个小型的容器镜像，他提供了一组正确的依赖项来运行您的原生程序。它基于 https://catalog.redhat.com/software/containers/ubi8-micro/601a84aadd19c7786c47c8ea?container-tabs=overview[UBI Micro]。此镜像经过定制，可以在容器中完美运行。

//You can read more about UBI images on:
您可以在以下文档中查看更多 UBI 镜像信息：

* https://www.redhat.com/en/blog/introducing-red-hat-universal-base-image[Universal Base Image 介绍]
* https://catalog.redhat.com/software/container-stacks/detail/5ec53f50ef29fd35586d9a56[Red Hat Universal Base Image 8]

//UBI images can be used without any limitations.
UBI 镜像可以不受任何限制的使用

//xref:quarkus-runtime-base-image.adoc[This page] explains how to extend the `quarkus-micro` image when your application has specific requirements.
xref:quarkus-runtime-base-image-CN.adoc[Quarkus 基础镜像] 中介绍如何让 `quarkus-micro` 拓展。
====

//Then, if you didn't delete the generated native executable, you can build the docker image with:
接下来，如果您没有删除生成的本地可执行文件，则可以使用如下命令构建 docker 镜像：

[source,bash]
----
docker build -f src/main/docker/Dockerfile.native -t quarkus-quickstart/getting-started .
----

//And finally, run it with:
最后，使用下面命令运行：
[source,bash]
----
docker run -i --rm -p 8080:8080 quarkus-quickstart/getting-started
----

//=== Manually using the minimal base image
=== 手动使用最小基础镜像

//The project generation has also provided a `Dockerfile.native` in the `src/main/docker` directory with the following content:
在项目生成的 `src/main/docker` 目录中提供了 `Dockerfile.native` 文件，内容如下。

[source,dockerfile]
----
FROM registry.access.redhat.com/ubi8/ubi-minimal:8.5
WORKDIR /work/
COPY target/*-runner /work/application
RUN chmod 775 /work
EXPOSE 8080
CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
----

//The UBI minimal image is bigger than the micro one mentioned above.
//It contains more utilities such as the `microdnf` package manager.

UBI 最小镜像要比上面生成的镜像稍微大一些，它包含更多实用的程序，例如 `microdnf` 包管理器。

[#multistage-docker]
//=== Using a multi-stage Docker build
=== 多阶段 Docker 构建

//The previous section showed you how to build a native executable using Maven or Gradle, but it requires you to have created the native executable first.
//In addition, this native executable must be a Linux 64 bits executable.

上一节向您演示了如何使用 Maven 或者 Gradle 构建本地可执行文件，但这要求您首先创建一个本地可执行文件。同时，本地可执行文件还要求是 Linux 64位的可执行文件。


//You may want to build the native executable directly in a container without having a final container containing the build tools.
//That approach is possible with a multi-stage Docker build:
您可能希望直接在容器中构建本地可执行文件，并且不需要包含构建工具的最终容器。这种方法可以使用多阶段Docker构建实现：


//1. The first stage builds the native executable using Maven or Gradle
1. 第一阶段使用Maven或Gradle构建本地可执行文件。
//2. The second stage is a minimal image copying the produced native executable
2. 第二阶段是复制可执行文件制作成最小镜像。

//Such a multi-stage build can be achieved as follows:
这样的多阶段构建可以通过以下操作实现：

//Sample Dockerfile for building with Maven:
使用 Maven 构建镜像的Dockerfile示例如下：
[source,dockerfile,subs=attributes+]
----
## Stage 1 : build with maven builder image with native capabilities
FROM quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor} AS build
COPY --chown=quarkus:quarkus mvnw /code/mvnw
COPY --chown=quarkus:quarkus .mvn /code/.mvn
COPY --chown=quarkus:quarkus pom.xml /code/
USER quarkus
WORKDIR /code
RUN ./mvnw -B org.apache.maven.plugins:maven-dependency-plugin:3.1.2:go-offline
COPY src /code/src
RUN ./mvnw package -Pnative

## Stage 2 : create the docker final image
FROM quay.io/quarkus/quarkus-micro-image:1.0
WORKDIR /work/
COPY --from=build /code/target/*-runner /work/application

# set up permissions for user `1001`
RUN chmod 775 /work /work/application \
  && chown -R 1001 /work \
  && chmod -R "g+rwX" /work \
  && chown -R 1001:root /work

EXPOSE 8080
USER 1001

CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
----

//NOTE: This multi-stage Docker build copies the Maven wrapper from the host machine.
//The Maven wrapper (or the Gradle wrapper) is a convenient way to provide a specific version of Maven/Gradle.
//It avoids having to create a base image with Maven and Gradle.
//To provision the Maven Wrapper in your project, use: `mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.0:wrapper`.

NOTE: 这哦多阶段Docker构建从主机复制 Maven Wrapper。Maven Wrapper（或者Gradle Wrapper）是提供特定版本的Maven、Gradle快捷工具。它避免使用Maven和Gradle的基础镜像。您需要在项目中配置 Maven Wrapper，具体命令：`mvn -N org.apache.maven.plugins:maven-wrapper-plugin:3.1.0:wrapper`



Save this file in `src/main/docker/Dockerfile.multistage` as it is not included in the getting started quickstart.
将该文件保存在 `src/main/docker/Dockerfile.multistage` 文件中，因为入门程序中不包含它。

//Sample Dockerfile for building with Gradle:
使用 Gradle 构建镜像的Dockerfile示例如下：

[source,dockerfile,subs=attributes+]
----
## Stage 1 : build with maven builder image with native capabilities
FROM quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor} AS build
COPY --chown=quarkus:quarkus gradlew /code/gradlew
COPY --chown=quarkus:quarkus /code/gradle
COPY --chown=quarkus:quarkus build.gradle /code/
COPY --chown=quarkus:quarkus settings.gradle /code/
COPY --chown=quarkus:quarkus gradle.properties /code/
USER quarkus
WORKDIR /code
COPY src /code/src
RUN gradle -b /code/build.gradle buildNative

## Stage 2 : create the docker final image
FROM quay.io/quarkus/quarkus-micro-image:1.0
WORKDIR /work/
COPY --from=build /code/build/*-runner /work/application
RUN chmod 775 /work
EXPOSE 8080
CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
----

//If you are using Gradle in your project, you can use this sample Dockerfile.  Save it in `src/main/docker/Dockerfile.multistage`.
如果您在项目中使用 Gradle ，则可以使用此示例中的Dockerfile，将其保存在 `src/main/docker/Dockerfile.multistage` 文件中。
[WARNING]
====
//Before launching our Docker build, we need to update the default `.dockerignore` file as it filters everything except the `target` directory. As we plan to build inside a container, we need to copy the `src` directory. Thus, edit your `.dockerignore` and update the content.
在启动 Docker 构建之前，我们需要更新默认的 `.dockerignore` 文件，因为它会过滤除 `target` 目录之外的所有内容。当我们计划在容器内构建时，我们需要复制 `src` 目录，因此，编辑您的 `.dockerignore` 内容。
====

[source,bash]
----
docker build -f src/main/docker/Dockerfile.multistage -t quarkus-quickstart/getting-started .
----

//And, finally, run it with:
最后，运行下面命令启动镜像：
[source,bash]
----
docker run -i --rm -p 8080:8080 quarkus-quickstart/getting-started
----

[TIP]
====
//If you need SSL support in your native executable, you can easily include the necessary libraries in your Docker image.
如果宁的本地可执行文件需要SSL支持，您可以轻松地在Docker镜像中添加所需库。

//Please see xref:native-and-ssl.adoc#working-with-containers[our Using SSL With Native Executables guide] for more information.
更多信息请查看 xref:native-and-ssl-CN.adoc#working-with-containers[SSL 与本机可执行文件一起使用指南]
====

//NOTE: To use Mandrel instead of GraalVM CE, update the `FROM` clause to: `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build`.
//`$TAG` can be found on the https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel Images Tags page].

NOTE: 如果使用 Mandrel 而不是 GraalVM CE ,则需要将 `FROM` 更新为 `FROM quay.io/quarkus/ubi-quarkus-mandrel:$TAG AS build`， `$TAG` 可以在 https://quay.io/repository/quarkus/ubi-quarkus-mandrel?tab=tags[Quarkus Mandrel Images 标签说明] 上查看

//=== Using a Distroless base image
=== 使用 Distroless 基础镜像

//IMPORTANT: Distroless image support is experimental.
IMPORTANT: 支持 Distroless 镜像是一个实验性的功能

//If you are looking for small container images, the https://github.com/GoogleContainerTools/distroless[distroless] approach reduces the size of the base layer.
//The idea behind _distroless_ is the usage of a single and minimal base image containing all the requirements, and sometimes even the application itself.
如果您在寻找小型容器镜像 https://github.com/GoogleContainerTools/distroless[distroless] 是一个不错的选择。distroless背后的想法是使用一个包含所有的需求的最小镜像，有时候可以是应用程序本身。

//Quarkus provides a distroless base image that you can use in your `Dockerfile`.
//You only need to copy your application, and you are done:
Quarkus 提供了一个无法行版本的基础镜像，您可以查看下面 `Dockerfile` ，您如果需要将其执行即可获得Quarkus镜像。


[source, dockerfile]
----
FROM quay.io/quarkus/quarkus-distroless-image:1.0
COPY target/*-runner /application

EXPOSE 8080
USER nonroot

CMD ["./application", "-Dquarkus.http.host=0.0.0.0"]
----

//Quarkus provides the `quay.io/quarkus/quarkus-distroless-image:1.0` image.
Quarkus 提供 `quay.io/quarkus/quarkus-distroless-image:1.0` 镜像。
//It contains the required packages to run a native executable and is only **9Mb**.
它包含允许本地可执行文件所需的包，容量只有 **9Mb**
//Just add your application on top of this image, and you will get a tiny container image.
只需要将您的应用程序添加在此镜像纸上，您就可以获得一个较小的容器镜像。

//Distroless images should not be used in production without rigorous testing.
Distroless镜像没有做严格的测试，不建议在生产环境中使用

//=== Native executable compression
=== 压缩本地可执行文件

//Quarkus can compress the produced native executable using UPX.
//More details on xref:./upx.adoc[UPX Compression documentation].

Quarkus可以使用 UPX 对本地可执行文件进行压缩，具体内容查看  xref:./upx.adoc[UPX 压缩文档]


//=== Separating Java and native image compilation
=== 分离 Java 和原生镜像编译

//In certain circumstances, you may want to build the native image in a separate step.
//For example, in a CI/CD pipeline, you may want to have one step to generate the source that will be used for the native image generation and another step to use these sources to actually build the native executable.
//For this use case, you can set the `quarkus.package.type=native-sources`.
//This will execute the java compilation as if you would have started native compilation (`-Pnative`), but stops before triggering the actual call to GraalVM's `native-image`.
在某些情况下，您可能希望单独构建本地可执行文件，例如，在CI/CD中，您可能希望有一个步骤来生成本地可执行文件，而另一步是完成镜像创建。对于此用例您可以设置 `quarkus.package.type=native-sources` 属性，这样将执行 java 编译，这和镜像编译（`Pnative`)一样，但会停止 `native-image` 调用。


[source,bash]
----
$ ./mvnw clean package -Dquarkus.package.type=native-sources
----

//After compilation has finished, you find the build artifact in `target/native-sources`:
编译完成后，您可以在 `target/native-sources` 位置找到构件结果

[source,bash]
----
$ cd target/native-sources
$ ls
native-image.args  getting-started-1.0.0-SNAPSHOT-runner.jar lib
----

//From the output above one can see that, in addition to the produced jar file and the associated lib directory, a text file named `native-image.args` was created.
//This file holds all parameters (including the name of the JAR to compile) to pass along to GraalVM's `native-image` command.
//If you have GraalVM installed, you can start the native compilation by executing:

从上面的输出可以看到，除了生成jar文件和相关的lib目录之外，还创建了名为 `native-image.args` 的文件。该文件包含所有参数（包括编译Jar的名称）以传递给GraalVM的 `native-image` 命令。如果您安装了 GraalVM可以通过以下命令开始编译。

[source,bash]
----
$ cd target/native-source
$ native-image $(cat native-image.args)
...
$ ls
native-image.args
getting-started-1.0.0-SNAPSHOT-runner
getting-started-1.0.0-SNAPSHOT-runner.build_artifacts.txt
getting-started-1.0.0-SNAPSHOT-runner.jar
----

//The process for Gradle is analogous.

//Running the build process in a container is also possible:
使用 Gradle 与上述过程类似，也可以在容器中运行构建：


[source,bash,subs=attributes+]
----
cd target/native-image
docker run \
  -it \
  --rm \
  --v $(pwd):/work <1>
  -w /work <2>
  --entrypoint bin/sh \
  quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor} \ <3>
  -c "native-image $(cat native-image.args) -J-Xmx4g" <4>
----

//<1> Mount the host's directory `target/native-image` to the container's `/work`. Thus, the generated binary will also be written to this directory.
<1> 将 `target/native-image` 目录挂载到容器的 `/work` 目录，生成的二进制文件也将写入在该目录
//<2> Switch the working directory to `/work`, which we have mounted in <1>.
<2> 将工作目录切换到 `/work`
//<3> Use the `quay.io/quarkus/ubi-quarkus-native-image:{graalvm-flavor}` docker image introduced in <<#multistage-docker,Using a multi-stage Docker build>> to build the native image.
<3> 使用<<#multistage-docker, 多阶段 Docker 构建>> 中介绍的内容进行原生镜像的构建。
//<4> Call `native-image` with the content of file `native-image.args` as arguments. We also supply an additional argument to limit the process's maximum memory to 4 Gigabytes (this may vary depending on the project being built and the machine building it).
<4> 使用 `native-image.args` 文件中的参数作为 `native-image` 命令的参数。我们还提供了一个额外的参数来限制最大使用内存，限制为4GB。

[WARNING]
====
//If you are running on a Windows machine, please keep in mind that the binary was created within a Linux docker container.
//Hence, the binary will not be executable on the host Windows machine.
如果您在Windows机器上运行，请记住二进制文件是在 Linux docker 容器中创建的，因此，该二进制文件无法在Windows机器上运行。
====

//A high level overview of what the various steps of a CI/CD pipeline would look is the following:
以下是 CI/DI 中的高级操作

1. Register the output of the step executing `./mvnw ...` command (i.e. directory `target/native-image`) as a build artifact,
2. Require this artifact in the step executing the `native-image ...` command, and
3. Register the output of the step executing the `native-image ...` command (i.e. files matching `target/*runner`) as build artifact.

//The environment executing step `1` only needs Java and Maven (or Gradle) installed, while the environment executing step `3` only needs a GraalVM installation (including the `native-image` feature).
执行步骤 `1` 只需要安装 Java 和 Maven （或Gradle)，而执行步骤 `3` 只需要安装 GraalVM （包括 `native-image` 功能）


//Depending on what the final desired output of the CI/CD pipeline is, the generated binary might then be used to create a container image.
根据 CICD 管道的最终期望输出，生成的二进制文件可能会用于创建容器映像。

//== Debugging native executable
== 调试本机可执行文件

//Starting with Oracle GraalVM 20.2 or Mandrel 20.1,
//debug symbols for native executables can be generated for Linux environments
//(Windows support is still under development, macOS is not supported).
//These symbols can be used to debug native executables with tools such as `gdb`.
从 Oracle GraalVM 20.2 或 Mandrel 20.1 开始，可以为 Linux 环境生成本机可执行文件的调试符号（Windows 支持仍在开发，不支持macOS）。这些符号可用于 `gdb` 。


//To generate debug symbols,
//add `-Dquarkus.native.debug.enabled=true` flag when generating the native executable.
//You will find the debug symbols for the native executable in a `.debug` file next to the native executable.

如果需要生成调试符号，可以使用 `-Dquarkus.native.debug.enabled=true` 参数配置， `.debug` 您将在本地可执行文件中找到调试符号。


[NOTE]
====
//The generation of the `.debug` file depends on `objcopy`.
//On common Linux distributions you will need to install the `binutils` package:

文件生成的 `.debug` 取决于 `objcopy` 。在Linux发行版上，您需要安装 `binutils`

[source,bash]
----
# dnf (rpm-based)
sudo dnf install binutils
# Debian-based distributions
sudo apt-get install binutils
----

When `objcopy` is not available debug symbols are embedded in the executable.
当 `objcopy` 不可用时，调试符号将嵌入在可执行文件中。
====

Aside from debug symbols,
setting `-Dquarkus.native.debug.enabled=true` flag generates a cache of source files
for any JDK runtime classes, GraalVM classes and application classes resolved during native executable generation.
This source cache is useful for native debugging tools,
to establish the link between the symbols and matching source code.
It provides a convenient way of making just the necessary sources available to the debugger/IDE when debugging a native executable.


//Sources for third party jar dependencies, including Quarkus source code,
//are not added to the source cache by default.
//To include those, make sure you invoke `mvn dependency:sources` first.
//This step is required in order to pull the sources for these dependencies,
//and get them included in the source cache.

默认情况下，第三方jar依赖（包括Quarkus源码）不会添加到缓存源。通过 `mvn dependency:sources` 命令将依赖源进行获取


//The source cache is located in the `target/sources` folder.
缓存源文件位于 `target/sources` 目录

[TIP]
====
//If running `gdb` from a different directory than `target`, then the sources can be loaded by running:
如果使用 `gdb` 从不同目录运行 `target` 需要通过下面命令添加源
[source,bash]
----
directory path/to/target
----

//in the `gdb` prompt.
//
//Or start `gdb` with:
使用 `gdb` 启动：

[source,bash]
----
gdb -ex 'directory path/to/target' path/to/target/{project.name}-{project.version}-runner
----

//e.g.,
示例：
[source,bash]
----
gdb -ex 'directory ./target' ./target/getting-started-1.0.0-SNAPSHOT-runner
----
====

//For a more detailed guide about debugging native images please refer to the xref:native-reference.adoc[Native Reference Guide].
有关调试本机可执行文件的内容可以查看 xref:native-reference-CN.adoc[原生参考指南].

[[configuration-reference]]
//== Configuring the Native Executable
== 配置本机可执行文件

There are a lot of different configuration options that can affect how the native executable is generated.
These are provided in `application.properties` the same as any other config property.

The properties are shown below:


有许多不同的配置选项会影响本机可执行文件的生成方式。这些配置可以在 `application.properties` 文件中与任何其他配置属性一样提供。
属性如下所示：

include::{generated-dir}/config/quarkus-native-pkg-native-config.adoc[opts=optional]

//== What's next?
== 下一步是什么？

//This guide covered the creation of a native (binary) executable for your application.
//It provides an application exhibiting a swift startup time and consuming less memory.
//However, there is much more.

We recommend continuing the journey with the xref:deploying-to-kubernetes.adoc[deployment to Kubernetes and OpenShift].

本教程涵盖了如何为您的应用程序创建本机（二进制）可执行文件。它提供了一种应用程序，该应用程序具有快速启动时间并消耗更少的内存。然而，还有更多。我们建议继续阅读 xref:deploying-to-kubernetes.adoc[部署到 Kubernetes 和 OpenShift]。

